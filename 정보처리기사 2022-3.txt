--- [정보처리기사 - 2022-3]

--- 01. 아래는 C언어의 2차원 배열 형태이다. field의 경우 2차원 배열 형태는 예시처럼 출력되므로, 이를 참고하여 mines의
	2차원 배열 형태를 작성하시오	◆
	  ===========================================================================================================
	> void main
	  {
	      field {{0,1,0,1}, {0,0,0,1}, {1,1,1,0}, {0,1,1,1}};
	      mines {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}};

	      int w = 4, h = 4;
	      for(y=0; y<h; y++)
	      {
		  for(x=0; x<w; x++)
		  {
		      if(field[y][x] == 0)
			continute;
		      for(i=y-1; i<y+1; i++)
		      {
			  for(j=x-1; j<x+1; j++)
			  {
			      if(calculate(w,h,j,i) == 1)
			      {
				  mines[i][j] += 1;
			      }
			  }
		      }
		  }
	      }

	      for(y=0; y<h; y++)
	      {
		  for(x=0; x<w; x++)
		  {
		      printf("%d", mines[y][x]);
		      printf("\n");
		  }
	      }
	  }

	  int calculate(w,h,j,i)
	  {
	      if(i>=0 && i<h && J>=0 && j < w ) return 1;
	      return 0;
	  }
	  ===========================================================================================================
	  > [0 1 0 1]	> [1 1 3 2]
	    [0 0 0 1]	  [3 4 5 3]
	    [1 1 1 0]	  [3 5 6 4]
	    [0 1 1 1]	  [3 5 5 3]

	    - 특정 지점의 x축 y축으로 이전 이후에 대한 조사를 할 때
	      해당 지점으로부터 -1 ~ +1까지를 조사하는 것임..
	      따라서 배열지점(자기자신포함)한 값의 한칸당 주변의 1의 갯수가 있는만큼 1을 더해지기때문에
	      정답 배열은 이전 배열의 지점 주변의 1값의 합산이 됀다.

--- 02. 아래 예시를 보고 관계 대수에 대한 기호를 작성하시오.
	  ===========================================================================================================
	> [항목]		[기호]
	  합집합		A(∪)B
	  차집합		A(-)B
	  카티션 프로덕트	A(χ)B	---> 맞췃다. X
	  프로젝트		A(π)B
	  조인			A(▷◁)B
	  ===========================================================================================================

--- 03. 다음은 디자인 패턴에 대한 설명이다. 괄호안에 알맞는 답을 작성하시오.
	> (1) 은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.
	  구현뿐 아니라 추상화도 독립적 변경이 필요할 때 브리지 패턴을 사용한다.
	  기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며, 새로운 인터페이스를 정의하여
	  기존 프로그램의 변경 없이 기능을 확장할 수 있다.

	> (2) 은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.
	  일대다 관계를 가지며, 주로 분산된 시스템 간에 이벤트를 생성,발행(Publish)하고 이를 수신(Subscribe)해야 할때
	  이용한다.

	  - Bridge Pattern / Observer Pattern

--- 04. 아래 코드에 대한 출력 값을 작성하시오.
	  ===========================================================================================================
	> void main
	  {
	      int [] result = int [5];
	      int [] arr = [77, 32, 10, 99, 50];

	      for(int i=0; i<5; i++)
	      {
		  result[i] = 1;
		  for(int j = 0; i<5 j++)
		  {
		      if(arr[i]< arr[j]) result[i] ++;
		  }
	      }

	      for(int k = 0; k< 5; k++)
	      {
		  printf(result[k]);
	      }
	  }
	  ===========================================================================================================
	  - 24513

--- 05. 아래 코드에 대한 출력 값을 작성하시오.	◆
	> 첫번째 네트워크 주소가 192.168.1.0/26 일때 FLSM 3개로 분할했을 때
	  두번째 네트워크 브로드캐스트 IP를 10진수로 변환한 값을 작성하시오.
	  - 192.168.1.127 64(X)

--- 06. 아래 표를 확인하여 보기에 알맞는 값을 고르시오
	  ===========================================================================================================
	> [점수]	[금액]
	  90~100	700만원
	  80~89		500만원
	  70~79		300만원
	  0~69		0원
	  ===========================================================================================================
	  - [테스트 케이스] [1]  [2] [3] [4]  [5]  [6]  [7] [8] [9] [10] [11] [12] [13] [14] [15]
	    [입력값]	    [-1] [0] [1] [69] [70] [71] [79] ...
	    [결과값]	    [er] [0] [1] [0]  [300]
	  ===========================================================================================================
	    > Boundary Value Analysis

--- 07. 아래 데이터 명령어를 적용할 경우 알맞는 출력값을 작성하시오.
	  ===========================================================================================================
	> CREATE TABLE 부서
	  (
	      부서코드 int, 부서명 varchar(50)
	      PRIMARY KEY (부서코드)
	      FOREIGN KEY (부서코드)
	      REFERENCES 직원(부서코드)
	      ON DELETE CASCADE
	  );
	  ===========================================================================================================
	  ===========================================================================================================
	  CREATE TABLE 직원 
	  (
	      직원코드 int, 부서코드 int
	      PRIMARY KEY (직원코드)
	      FOREIGN KEY (부서코드) REFERENCES 부서(부서코드)
	  );
	  ===========================================================================================================
	  insert into 부서 (부서코드, 부서명) value (10, 영업부);
	  insert into 부서 (부서코드, 부서명) value (20, 기획부);
	  insert into 부서 (부서코드, 부서명) value (30, 개발부);

	  insert into 직원 (직원코드, 부서코드) value (1000, 10);
	  insert into 직원 (직원코드, 부서코드) value (2000, 10);
	  insert into 직원 (직원코드, 부서코드) value (3000, 20);
	  insert into 직원 (직원코드, 부서코드) value (4000, 20);
	  insert into 직원 (직원코드, 부서코드) value (5000, 20);
	  insert into 직원 (직원코드, 부서코드) value (6000, 30);
	  insert into 직원 (직원코드, 부서코드) value (7000, 30);
	  ===========================================================================================================

	  > SELECT DISTINCT COUNT(직원코드) FROM 직원 WHERE 부서코드 = '20';
	    ( 1 )
	  > DELETE FROM 부서 WHERE 부서코드 = '20';
	    SELECT DISTINCT COUNT (직원코드) FROM 직원;
	    ( 2 )

	    - 1 : 3, 2 : 4

--- 08. 아래 설명에 대한 알맞는 답을 작성하시오. ◆
	> (1) 은/는 보안학적 측면에서 기술적인 방법이 아닌 사람들간의 기본적인 신뢰를 기반으로 사람을 속여 비밀정보를
	  획득하는 기법이다.
	> (2) 은/는 빅데이터(Big Data)와 비슷하면서도 구조화돼 있지 않고, 더는 사용하지 않는 '죽은' 데이터를 의미한다
	  . 일반적으로 정보를 수집해 저장한 이후 분석이나 특별한 목적을 위해 활용하는 데이터가 아니며 저장공간만 차지
	  하고 이러한 이유로 심각한 보안 위험을 초래할 수 있다.
	  - 1 : 사회공학, 2 : 다크 데이터 --> 틀렸다.

--- 09. 다음 파이썬 코드에 대한 출력값을 작성하시오
	> TestList = [1, 2, 3, 4, 5]
	  TestList = list(map(lambda num : num + 100, TestList)))
	  print (TestList)
	  - [101, 102, 103, 104, 105]

--- 10. 다음 보안 관련 설명으로 가장 알맞는 용어를 작성하시오. ◆
	> ( ) 은/는 머신러닝 기술을 이용하여 IT 시스템에서 발생하는 대량의 로그를 통합 관리 및 분석하여 사전에 위협에
	  대응하는 보안 솔루션이다.
	> 서로 다른 기종의 보안솔루션 로그 및 이벤트를 중앙에서 통합 수집하여 분석할 수 있으며, 네트워크 상태의 monit
	  oring 및 이상징후를 미리 감지할 수 있다.
	  - 네트워크 이기종 장비 간 로그의 상관관계 분석
	  - 이상징후의 행위 기반 및 문맥 기반 분석 가능
	  - 각 로그의 상관관계를 조건식에 따라 검색하여 분석이 가능
	  - 이벤트 및 로그의 이상패턴을 인식해 잠재적 위협이 발생 시 알림 기능

	    > SIEM(Security Information and event management)
	    

--- 11. 다음 보기 중, 형상 관리 항목을 3가지 고르시오.
	ㄱ. ATM		ㄴ. CVS		ㄷ. OLAP
	ㄹ. DDOS	ㅁ. SVN		ㅂ. Cyber Kill Chain
	ㅅ. OLTP	ㅇ. GIT
	
	> ㄴ, ㅁ, ㅇ

--- 12. STUDENT 테이블에서 컴퓨터과 학생 50명, 전기과 학생 100명, 인터넷과 학생 50명의 정보가 저장되어 있을 때 다음 S
	QL문의 실행 결과에 따른 튜플의 수는? (단 DEPT 칼럼은 학과명이다.)
	> SELECT DEPT FROM STUDENT;
	> SELECT DISTINCT DEPT FROM STUDENT;
	> SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '인터넷과';
	  - 200
	  - 3
	  - 1

--- 13. 다음 코드에 대한 출력 값을 작성하시오. ◆
	  ===========================================================================================================
	> int n;
	  int k;
	  int s;
	  int el = 0;
	  for(n=6; n<=30; n++)
	  {
	      s=0;
	      k=n/2;
	      for(int j=1; j<=k; j++)
	      {
		  if(n%j==0)
		  {
		      s=s+j;
		  }
	      }

	      if(s==n)
	      el++;
	  }
	
	  printf("%d", el);

	  // 1회전
	  n = 6				
	  k = 3
	  	j = [1, 2, 3]
	        s = 6					-- 6
		
	  n = 7
	  n = 8
		j = 1 2 3
		s = 3

	  n = 9
	  n = 10
		j = 1 2 3 4
		s = 3

	  n = 11
	  n = 12
		j = 1 2 3 4 5
		s = 1 + 2 + 3 + 4 = 10

	  n = 13
	  n = 14
		j = 1 2 3 4 5 6
		s = 1 2

	  n = 15
	  n = 16 
	 	j = 1 2 3 4 5 6 7
		s = 1 + 2 + 4 + 

	  n = 17
	  n = 18
		j = 1 2 3 4 5 6 7 8 
		s = 1 2 3 6

	  n = 19
	  n = 20
		j = 1 2 3 4 5 6 7 8 9 
		s = 1 2 4 5 

	  n = 24
		j = 1 2 3 4 5 6 7 8 9 10 11		
		s = 1 2 3 4 6 8	12

	  n = 27
		j = 1 2 3 4 5 6 7 8 9 10 11 12
		s = 1 3 9

	  n = 28
		j = 1 2 3 4 5 6 7 8 9 10 11 12 13 	-- 28
		s = 1 2 4 7 14

	  n = 30
		j = 1 2 3 4 5 6 7 8 9 10
		s = 1 2 3 5 6 10			 
	  ===========================================================================================================	
	
	  - 1 (2) --> 문제 잘못봄

--- 14. 아래 설명에 대하여 알맞는 답을 보기에서 고르시오 ◆
	> ( 1 ) 은/는 프로세서(processor)안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 ARM 사에서 개발한
	  하드웨어 기반의 보안 기술로 프로세서(processor) 안에 독립적인 보안 구역을 별도로 하여, 중요한 정보를 보호하
	  는 하드웨어 기반의 보안 기술이다.

	> ( 2 ) 은/는 사용자들이 사이트에 접속할 때 주소를 잘못입력하거나 절차를 빠뜨리는 실수를 이용하기 위해 유사한
	  유명 도메인을 미리 등록하는 일로 URL 하이재킹(hijacking)이라고도 한다.
	  - 1 : Security Zone --> Trustzone , 2 : --> typosquatting

--- 15. 아래 설명에 대하여 알맞는 용어를 작성하시오. ◆
	> ()은/는 여러 개의 사이트에서 한번의 로그인으로 여러가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법을
	  말한다. 일반적으로 서로다른 시스템 및 사이트에서 각각의 사용자 정보를 관리하게 되는데 이때 하나의 사용자 정
	  보를 기반으로 여러 시스템을 하나의 통합 인증을 사용하게 하는 것을 말한다.

	> 즉 하나의 시스템에서 인증을 할 경우 타시스템에서는 인증정보가 있는지 확인하고 있으면 로그인처리를 하도록 하
	  고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것을 의미한다.

	  - OAuth --> SSO (Single Sign On)

--- 16. 다음은 스케줄링에 관한 내용이다. 괄호안에 알맞는 답을 작성하시오. ◆
	=============================================================================================================
	[스케줄링]		[내용]
	() 스케줄링		Ready Queue 에 있는 프로세스 중 CPU 처리 시간이 짧은 순서대로 CPU를 할당하는 비선점형
				방식이며, 늦게 도착하더라도 CPU 처리 시간이 앞에 대기중인 프로스세보다 짧으면 먼저 CP
				U를 할당받을 수 있다.

	() 스케줄링		프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당량(또는 시간간격)
				)에 의해 실행을 제한한다. 즉 시간 할당량을 매 프로세스에 주고 할당된 시간 안에 완료하
				지 못한 프로세스는 준비 큐의 맨뒤에 배치되도록 하여 CPU를 독점하지 않고 공평하게 이용
				될 수 있게 한다.

	() 스케줄링		선점 스케줄링 방식으로 변경한 기법이다. CPU를 점유중인 프로세스보다 남은 CPU 처리시간
				이 짧은 프로세스가 Ready Queue에 들어올 경우 새로들어온 프로세스가 CPU를 점유할 수 있
				다. 어떤 알고리즘보다 평균 대기 시간이 가장 짧은 알고리즘이지만, 기본적으로 선점형 방
				식이기 때문에 잦은 Context Switching이 일어나고 그에 따른 오버헤드가 커진다.
	=============================================================================================================
	- 비선점형 SJF
	- 시간할당형 RR
	- 선점형 SRT

	  * 비선점형
	    > FCFS(First Come First Served Scheduling)
	      - 선입 선처리 스케줄링은 먼저 자원을 요청한 프로세스에게 자원을 할당해주는 방식의 스케줄링 알고리즘
	    > SJF(Shortest Job First Scheduling)
	      - 최단 작업 우선 스케줄링은 평균 대기시간을 최소화하기 위해 CPU 점유시간이 가장짧은 프로세스에 CPU를 먼
		저 할당하는 방식의 CPU 스케줄링 알고리즘
	      - 평균 대기시간을 최소로 만드는 걸 최적으로 두고 있는 알고리즘
	      - 요구 시간이 긴 프로세스가 요구 시간이 짧은 프로세스에게 항상 양보되어 기아 상태가 발생할 수 있음
	      - 대기 상태에 있는 프로세스의 요구시간에 대한 정확한 자료를 얻기 어렵다는 문제점 있음
	      - 장기 스케줄링에 유리

	    > HRRN(Highest Response Ration Next Scheduling)
	      - 최상 응답 비율 순서(Highest response ratio next, HRRN) 스케줄링은 프로세스 처리의 우선 순위를 CPU처리
		기간과 해당 프로세스의 대기 시간을 동시에 고려해 선정하는 스케줄링 알고리즘
	      - SJF 스케줄링의 문제점을 보완해 개발된 스케줄링
	      - 우선순위 결정식
		> Priority = waiting time(대기시간) + estimated run time / estimated run time(처리시간)

	  * 선점형
	    > RR(Round Robin Scheduling)
	      - 라운드 로빈 스케줄링은 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로, 프로세스들 사이에 우선순
		위를 두지 않고, 순서대로 시간단위(Time Quantum)로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘
	      - 보통 시간 단위는 10ms ~ 100ms 정도이다.
	      - 시간 단위동안 수행한 프로세스는 준비 큐의 끝으로 밀려나게 된다.
	      - 문맥 전환의 오버헤드가 큰 반면, 응답시간이 짧아지는 장점이 있어 실시간 시스템에 유리하다.
	      - 사발통문과 마찬가지로, 사람의 이름을 순서대로 적는것이 아니라 원형으로 적어 조직의 서열을 숨기는 서명
		방식이다. (라운드 로빈)

	    > SRTF(Shortest Remaining-Time First Scheduling)
	      - 최소 잔류 시간 우선 스케줄링은 SJF 스케줄링을 비선점에서 선점 형태로 수정한 스케줄링 알고리즘
	      - 현재 작업중인 프로세스를 중단시키고 새로 들어온 프로세스의 처리를 시작하는 방식
	      - SRT, SRTF 스케줄링 이라고도 함.

	    > 다단계 큐(Multilevel Queue Scheduling)
	      - 커널 내의 준비 큐를 여러 개의 큐로 분리하여 큐 사이에도 우선순위를 부여하는 스케줄링 알고리즘
	      - 각각의 큐에 대해 다른 스케줄링 알고리즘을 적용하기도 함

	    > 다단계 피드백 큐(Multilevel Feedback Queue Scheduling)
	      - 다단계 큐 스케줄링에서 한 단계 발전된 방식(1962년 페르난도 J.코바토가 개발)
	      - 다단계 큐 스케줄링에서는 프로세스가 하나의 큐에 영구적으로 할당되지만 다단계 피드백 큐 스케줄링에서는
		프로세스들이 큐를 갈아탈 수 있다. 그리고 작업들이 서로 다른 유형의 작업들로 분류될 경우 사용된다.

	    > RM(Rate Monotonic Scheduling)
	      - 비율 단조 스케줄링은 1973년 리우(Liu)와 래일랜드(Layland)가 제안한 실시간 시스템을 위한 스케줄링 정책
		이다. 비율 단조 기법이라고도 한다. 비율 단조 분석(rate-monotomic analysis, 줄여서 RMA)은 RMS의 배경이
		되는 이론으로서, 시간 당 CPU 사용률을 계산하여 프로세스들을 이상없이 수행할 수 있는지를 알아보는 일.

	      - 수행 주기가 가장 짧은 프로세스에 가장 높은 우선순위를 부여하는 방식

	    > EDF(Ealiest Deadline First Scheduling)
	      - 최단 마감 우선 스케줄링은 실시간 운영 체제에서 사용되는 동적 CPU 스케줄링 알고리즘의 하나이다. 프로세
		스를 우선순위 큐를 통해 수행한다. 스케줄링 이벤트가 일어날 때마다, 큐에서 마감시간이 가장 가까운 프로
		세스를 탐색하여 다음에 수행되도록 한다. 주기적인 작업 뿐만 아니라 단일처리기 환경에서 선점형 프로세스
		들을 스케줄링 할 수 있다.


--- 17. 다음은 UML에 관한 설명이다. 괄호안에 알맞는 답을 작성하시오. ◆
	> UML은 통합 모델링 언어로써, 시스템을 모델로 표현해주는 대표적인 모델링 언어이다.
	> 구성 요소로는 사물, ( 1 ), 다이어그램으로 이루어져 있으며, 구조 다이어그램 중, ( 2 )다이어그램은 시스템에서
	  사용되는 객체 타입을 정의하고, 그들 간의 존재하는 정적인 관계를 다양한 방식으로 표현한 다이어그램이다.
	> 또한 UML 모델링에서( 3 ) 은/는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야 하는 오퍼레이션 세트를
	  정의하는 모델 요소이다.
	  - 1 : 구조--> 관계, 2 : 클래스, 3 : 인터페이스

--- 18. 다음은 E-R다이어그램에 관한 설명이다. 괄호 안에 알맞는 답을 작성하시오.
			
			ㄴ	[DATA]

	ㄱ			|
	[학생]			|  ㄹ
				
	-학생과목
	-이름		ㄷ			[과목]
	-성별		-----	◆	-----		
	-나이					- 과목코드
					ㅂ	- 과목이름

	( 1 ) : 개체집합 - 관계집합 연결		ㄷ
	( 2 ) : 개체 집합과의 연결			ㅂ
	( 3 ) : 관계집합 - 관계집합의 속성 연결		ㄹ
	( 4 ) : 두 개체집합 사이에서 생성되는 값을 저장하는 속성 ㄴ
	( 5 ) : 같은 속성을 공유하는 개체들의 모임	ㄱ

--- 19. 다음 자바 코드에 대한 출력 값을 작성하시오.
	> public class Main 
	  {
	      static int [] MakeArray()
	      {
		  int [] tempArr = new int [4];
		  for(int i=0; i<tempArr.Length; i++)
		  {
		      tempArr[i] = i;
		  }

		  return tempArr;
	      }
	  }

	  public static void main (String [] args)
	  {
	      int [] intArr;
	      intArr = MakeArray();
	      for(int i = 0; i<intArr.Length; i++)
	      {
		  System.out.print(intArr[i]);
	      }
	  }

	  - 0123

--- 20. 다음 자바 코드에 대한 출력 값을 작성하시오.
	> public class Exam
	  {
	      public static void main(String [] args)
	      {
		  int a = 0;
		  for(int i = 1; i<999; i++)
		  {
		      if(a%3 ==0 && i%2!=0)
		          a=i;
		  }
	      }
	
	  }

 	  - 993